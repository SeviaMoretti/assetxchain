pallet-storage_ipfs
pallet-storage_ipfs::do_register_asset-->enc_data(链下)-->pallet-sto_ipfs::upload_enc_data(链下)-->调用pallet-dataassets::register_asset

##链下
数据加密：使用对称密钥或非对称加密方案对原始数据进行加密。
分片与哈希计算：将加密后的文件分片，计算Merkle Root（ raw_data_hash）。
上传至IPFS：将加密数据上传到IPFS节点，获得Data CID
**元数据构建**：创建一个包含Data CID、加密算法信息、文件大小、描述等信息的JSON文件，并上传至IPFS获取 Metadata CID。


##链上（pallet-sto_ipfs）
CID 校验：验证传入的CID格式是否合法。
确权触发：接收用户提交的存储信息，并调用pallet-dataassets进行资产注册（修改对应逻辑）。
存储状态维护：记录资产与IPFS CID的对应关系，以及质押金（存储资金）对应的存储有效期或激励状态。


数据资产---质押金-->两部分（质押金+存储费用池（assetid资产唯一对应的子账户,元证或权证交易后一小部分自动流入这个账户））
激励：优质数据奖励、数据创建者永久分成、
存储商扣费逻辑：1、（不能扣数据创建者的那部分分成）先从资产的子账户，若没有了；2、从质押金中扣，质押金低于某一额度（就不扣了）就将资产状态AssetStatus修改为Weak，一段时间后还是没有补充资产就会“死亡”


########需要修改的问题：pallet-dataassets中的authorize_market中资产授权给市场之后，资产所有者还能不能对资产进行交易，若所有者交易资产（授权给市场的），市场的
信用问题（还在市场上挂着的资产，被交易后，自动解除授权关系，因为延迟等问题，资产会在市场上挂一段时间，那么在这期间出现购买资产的买方，都会购买失败）


加密->raw_data_hash,data_size_bytes,encryption_info
上传ipfs->cid


register_provider(origin, endpoint) // 注册成为ipfs服务提供者（但是还得定期给他挑战，验证是否还存储着数据）
    origin: 签名账户（提供者账户）
    endpoint: Vec<u8>，节点的 IPFS 多地址（Multiaddr），方便客户端连接 
    调用pallet-collaterals：：pledge/unbond

register_ipfs_asset(origin, name, description, metadata_cid, raw_data_hash, data_size_bytes, encryption_info)
    name, description: 资产信息
    *metadata_cid*: Vec<u8>，IPFS 元数据地址
    raw_data_hash: H256，加密数据的哈希，用于完整性校验
    data_size_bytes: u64，文件大小，用于计算质押金
    encryption_info: EncryptionInfo 结构体，包含算法、参数哈希等（加密密钥怎么保存）
    调用pallet-dataassets::register_asset
    asset_id -> provider 映射 存储证明

submit_storage_proof(origin, asset_id, proof_data) // provider定期提供证明（分片证明（基于merkle tree）/简单的心跳）
    asset_id: [u8; 32]，资产唯一 ID
    proof_data: Vec<u8>，链下计算生成的证明数据

verify_storage_challenge(origin, asset_id)
    自动触发。OffChainWorker随机挑选资产，通过IPFS检查CID是否可达

settle_reward(origin, asset_id) // 存储提供者领取其通过证明获得的存储报酬（1、先从资产的子账户，若没有了；2、从质押金中扣，直到质押金低于某一额度）